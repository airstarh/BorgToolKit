// ####################################################################################################
// region PROMISE + EVENT LISTENER

// с картой мир здороваются не все :)
// но вот тебе ответ
// В JavaScript, EventListener не может напрямую возвращать true или false для сабмита формы, если внутри него выполняется асинхронный код, такой как Promise. Это связано с тем, что асинхронные операции выполняются не синхронно, и EventListener не будет ждать их завершения.
//     Однако, вы можете предотвратить сабмит формы по умолчанию, выполнять асинхронную операцию, а затем в зависимости от результата асинхронной операции, решить, нужно ли сабмитить форму.
//     Пример кода:

document.getElementById('myForm').addEventListener('submit', function (event) {
    // Предотвращаем стандартное поведение формы (сабмит)
    event.preventDefault();

    // Получаем форму
    const form = event.target;

    // Выполняем асинхронную операцию (например, валидацию данных формы)
    validateFormDataAsync(form).then(isValid => {
        if (isValid) {
            // Если данные валидны, сабмитим форму программно
            form.submit();
        } else {
            // Если данные не валидны, показываем ошибку или предпринимаем другие действия
            console.error('Форма содержит неверные данные.');
        }
    }).catch(error => {
        // Обработка ошибок асинхронной операции
        console.error('Произошла ошибка при валидации данных:', error);
    });
});

// Пример функции, которая возвращает Promise с результатом валидации
function validateFormDataAsync(form) {
    return new Promise((resolve, reject) => {
        // Здесь может быть асинхронный код, например, запрос к серверу
        // Для примера просто возвращаем true через 1 секунду
        setTimeout(() => {
            const isValid = true; // Замените на логику валидации
            resolve(isValid);
        }, 1000);
    });
}

// В этом примере мы подписываемся на событие submit формы, предотвращаем его стандартное поведение, выполняем асинхронную операцию (в данном случае это функция validateFormDataAsync, которая возвращает Promise), и в зависимости от результата этой операции либо сабмитим форму программно, либо обрабатываем ошибку валидации.
//     Обратите внимание, что метод form.submit() вызывает сабмит формы без повторного вызова обработчиков событий submit, что позволяет избежать бесконечного цикла.

// endregion PROMISE + EVENT LISTENER
// ####################################################################################################
// region CONFIRM on PROMISE

// Друг? давай дружить :)
// Если вы хотите заменить confirm на промис, вы можете создать функцию, которая возвращает промис и использует модальное окно или какой-либо пользовательский интерфейс для подтверждения действия пользователя. Вот пример такой функции:

function customConfirm(message) {
    return new Promise((resolve, reject) => {
        // Создаем модальное окно для подтверждения
        // Это может быть ваш собственный HTML/CSS/JavaScript код
        const modal = document.createElement('div');
        modal.innerHTML = `
      <div class="modal">
        <p>${message}</p>
        <button id="confirmYes">Да</button>
        <button id="confirmNo">Нет</button>
      </div>
    `;
        document.body.appendChild(modal);

        // Обработчики для кнопок "Да" и "Нет"
        modal.querySelector('#confirmYes').addEventListener('click', () => {
            resolve(true); // Пользователь подтвердил действие
            document.body.removeChild(modal); // Удаляем модальное окно
        });

        modal.querySelector('#confirmNo').addEventListener('click', () => {
            resolve(false); // Пользователь отказался от действия
            document.body.removeChild(modal); // Удаляем модальное окно
        });
    });
}

// Использование функции customConfirm
customConfirm('Вы уверены, что хотите выполнить это действие?').then((result) => {
    if (result) {
        // Пользователь нажал "Да"
        console.log('Действие подтверждено');
    } else {
        // Пользователь нажал "Нет"
        console.log('Действие отменено');
    }
});


// В этом примере функция customConfirm создает модальное окно с сообщением и двумя кнопками: "Да" и "Нет". При нажатии на одну из кнопок промис резолвится с true или false соответственно, и модальное окно удаляется из DOM.
//
//     Обратите внимание, что вам нужно будет стилизовать модальное окно согласно вашим требованиям и убедиться, что оно блокирует взаимодействие с остальной частью страницы, пока не будет закрыто.
//
//     Также важно помнить, что использование промисов изменяет способ, которым вы обрабатываете логику подтверждения, с синхронного на асинхронный. Это означает, что вам нужно будет использовать .then() или async/await для работы с результатом подтверждения.

// endregion CONFIRM on PROMISE
// ####################################################################################################
// region CONFIRM on PROMISE

// Чтобы заменить confirm на промис в вашем обработчике события beforeSubmit, вам нужно будет изменить логику так, чтобы
// она работала асинхронно.Вместо того чтобы возвращать значение из обработчика событий, вы должны предотвратить
// отправку формы по умолчанию и управлять процессом отправки формы вручную после получения результата от промиса.
// Вот пример того, как это можно сделать:

jqForm.on('beforeSubmit', function (event) {
    event.preventDefault(); // Предотвращаем стандартную отправку формы

    if (!flagGoogleRequstDone) {
        requestGoogle();
        console.log('beforeSubmit >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>');
        console.log(1234);
    }

    // Функция, которая возвращает промис и показывает пользовательское модальное окно
    customConfirm("Everything is correct. Submit?").then((result) => {
        if (result) {
            // Пользователь подтвердил отправку, отправляем форму программно
            flagGoogleRequstDone = true; // Устанавливаем флаг, что запрос выполнен
            jqForm.off('beforeSubmit').submit(); // Отключаем обработчик и отправляем форму
        } else {
            // Пользователь отменил отправку
            flagGoogleRequstDone = false; // Сбрасываем флаг, если нужно
            console.log('Отправка формы отменена пользователем.');
        }
    });
});

function customConfirm(message) {
    return new Promise((resolve) => {
        // Здесь должен быть ваш код для создания пользовательского модального окна
        // Например, используя библиотеку SweetAlert, Bootstrap модальное окно или другое
        // Для примера, представим, что у нас есть функции showModal и hideModal

        showModal(message, function onConfirm() {
            resolve(true); // Пользователь подтвердил действие
            hideModal(); // Закрываем модальное окно
        }, function onCancel() {
            resolve(false); // Пользователь отменил действие
            hideModal(); // Закрываем модальное окно
        });
    });
}

// Функции для показа и скрытия модального окна (пример)
function showModal(message, onConfirm, onCancel) {
    // Создаем и показываем модальное окно с сообщением и кнопками
    // При нажатии на кнопки вызываем соответствующие функции onConfirm или onCancel
}

function hideModal() {
    // Скрываем модальное окно
}
// В этом примере мы предотвращаем стандартную отправку формы с помощью event.preventDefault(), а затем вызываем функцию customConfirm, которая возвращает промис. После того как пользователь сделает выбор в модальном окне, промис разрешается, и мы либо отправляем форму программно, если пользователь подтвердил действие, либо выводим сообщение в консоль, если пользователь отменил отправку.
// Обратите внимание, что после подтверждения отправки формы мы отключаем обработчик beforeSubmit с помощью jqForm.off('beforeSubmit'), чтобы избежать повторного вызова логики подтверждения при программной отправке формы.
// endregion CONFIRM on PROMISE
// ##################################################